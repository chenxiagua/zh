import { __awaiter } from "tslib";
import { getEnvelopeEndpointWithUrlEncodedAuth } from '@sentry/core';
import { Transports } from '@sentry/node';
import { eventStatusFromHttpCode, logger, makePromiseBuffer } from '@sentry/utils';
import { net } from 'electron';
import { Readable } from 'stream';
import * as url from 'url';
import { createGzip } from 'zlib';
import { getSdkInfo } from '../context';
import { whenAppReady } from '../electron-normalize';
// Estimated maximum size for reasonable standalone event
const GZIP_THRESHOLD = 1024 * 32;
/** Wraps HTTP errors and includes the status */
export class HTTPError extends Error {
    constructor(status, message) {
        super(message);
        this.status = status;
    }
}
/**
 * Gets a stream from a Buffer or string
 * We don't have Readable.from in earlier versions of node
 */
function streamFromBody(body) {
    return new Readable({
        read() {
            this.push(body);
            this.push(null);
        },
    });
}
/** Using net module of Electron */
export class ElectronNetTransport extends Transports.BaseTransport {
    /** Create a new instance */
    constructor(options) {
        super(options);
        this.options = options;
        /** A simple buffer holding all requests. */
        this._buffer = makePromiseBuffer(30);
    }
    /**
     * @inheritDoc
     */
    sendEvent(event) {
        return __awaiter(this, void 0, void 0, function* () {
            const envelopeHeaders = JSON.stringify({
                event_id: event.event_id,
                sent_at: new Date().toISOString(),
            });
            const type = event.type || 'event';
            const itemHeaders = JSON.stringify({ type });
            if (this._isRateLimited(type)) {
                throw new HTTPError('rate_limit', `Transport locked till ${JSON.stringify(this._rateLimits, null, 2)} due to too many requests.`);
            }
            // Delete this metadata as this should not be sent to Sentry.
            delete event.sdkProcessingMetadata;
            const eventPayload = JSON.stringify(event);
            const body = Buffer.from(`${envelopeHeaders}\n${itemHeaders}\n${eventPayload}\n`);
            return this.sendRequest({
                url: getEnvelopeEndpointWithUrlEncodedAuth(this._api.dsn),
                body,
                type,
            });
        });
    }
    /**
     * @inheritDoc
     */
    sendSession(session) {
        const { name, version } = getSdkInfo();
        const envelopeHeaders = JSON.stringify({
            sent_at: new Date().toISOString(),
            sdk: { name, version },
        });
        // I know this is hacky but we don't want to add `session` to request type since it's never rate limited
        const type = 'aggregates' in session ? 'sessions' : 'session';
        const itemHeaders = JSON.stringify({ type });
        const sessionPayload = JSON.stringify(session);
        const body = Buffer.from(`${envelopeHeaders}\n${itemHeaders}\n${sessionPayload}\n`);
        return this.sendRequest({
            url: getEnvelopeEndpointWithUrlEncodedAuth(this._api.dsn),
            body,
            type,
        });
    }
    /**
     * Checks if a category is rate-limited
     */
    isRateLimited(category) {
        return this._isRateLimited(category);
    }
    /**
     * Dispatches a Request to Sentry. Only handles SentryRequest
     */
    sendRequest(request) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.log(`Sending '${request.type}' request`);
            if (this._isRateLimited(request.type)) {
                throw new HTTPError('rate_limit', `Transport for ${request.type} requests locked till ${this._disabledUntil(request.type)} due to too many requests.`);
            }
            const options = this._getRequestOptions(new url.URL(request.url));
            options.headers = Object.assign(Object.assign({}, options.headers), { 'Content-Type': 'application/x-sentry-envelope' });
            let bodyStream = streamFromBody(request.body);
            if (request.body.length > GZIP_THRESHOLD) {
                options.headers['Content-Encoding'] = 'gzip';
                bodyStream = bodyStream.pipe(createGzip());
            }
            yield whenAppReady;
            return this._buffer.add(() => new Promise((resolve, reject) => {
                const req = net.request(options);
                req.on('error', reject);
                req.on('response', (res) => {
                    res.on('error', reject);
                    const status = eventStatusFromHttpCode(res.statusCode);
                    if (status === 'success') {
                        resolve({ status });
                    }
                    else {
                        if (status === 'rate_limit') {
                            let retryAfterHeader = res.headers ? res.headers['retry-after'] : '';
                            retryAfterHeader = (Array.isArray(retryAfterHeader) ? retryAfterHeader[0] : retryAfterHeader);
                            let rlHeader = res.headers ? res.headers['x-sentry-rate-limits'] : '';
                            rlHeader = (Array.isArray(rlHeader) ? rlHeader[0] : rlHeader);
                            if (this._handleRateLimit({ 'x-sentry-rate-limits': rlHeader, 'retry-after': retryAfterHeader })) {
                                logger.warn(`Too many requests, backing off until: ${this._disabledUntil(request.type)}`);
                            }
                        }
                        if (res.headers && res.headers['x-sentry-error']) {
                            let reason = res.headers['x-sentry-error'];
                            if (Array.isArray(reason)) {
                                reason = reason.join(', ');
                            }
                            reject(new HTTPError(status, `HTTP Error (${res.statusCode}): ${reason}`));
                        }
                        else {
                            reject(new HTTPError(status, `HTTP Error (${res.statusCode})`));
                        }
                    }
                    // force the socket to drain
                    res.on('data', () => {
                        // Drain
                    });
                    res.on('end', () => {
                        // Drain
                    });
                });
                // The docs say that ClientRequest is Writable but the types don't match exactly
                bodyStream.pipe(req);
            }));
        });
    }
}
//# sourceMappingURL=electron-net.js.map