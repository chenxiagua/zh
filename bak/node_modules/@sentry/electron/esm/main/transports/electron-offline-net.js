import { __awaiter } from "tslib";
import { getEnvelopeEndpointWithUrlEncodedAuth } from '@sentry/core';
import { logger } from '@sentry/utils';
import { net } from 'electron';
import { join } from 'path';
import { sentryCachePath } from '../fs';
import { ElectronNetTransport, HTTPError } from './electron-net';
import { PersistedRequestQueue } from './queue';
const START_DELAY = 5000;
const MAX_DELAY = 2000000000;
/** Returns true is there's a chance we're online */
function maybeOnline() {
    return !('online' in net) || net.online === true;
}
/** Using net module of Electron */
export class ElectronOfflineNetTransport extends ElectronNetTransport {
    /** Create a new instance  */
    constructor(options) {
        super(options);
        this.options = options;
        this._queue = new PersistedRequestQueue(join(sentryCachePath, 'queue'));
        this._url = getEnvelopeEndpointWithUrlEncodedAuth(this._api.dsn);
        this._retryDelay = START_DELAY;
        this._flushQueue();
    }
    /**
     * @inheritDoc
     */
    sendRequest(request) {
        const _super = Object.create(null, {
            sendRequest: { get: () => super.sendRequest }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (maybeOnline()) {
                try {
                    const response = yield _super.sendRequest.call(this, request);
                    this._requestSuccess();
                    return response;
                }
                catch (error) {
                    if (error instanceof HTTPError && error.status !== 'rate_limit') {
                        // We don't queue HTTP errors that are not rate limited
                        logger.warn('Dropping request:', error);
                        return { status: 'failed' };
                    }
                    else {
                        logger.log('Error sending:', error);
                    }
                }
            }
            else {
                logger.log(`Currently Offline. Not sending '${request.type}' request. `);
            }
            return yield this._queueRequest(request);
        });
    }
    /** Records successful submission */
    _requestSuccess() {
        logger.log('Successfully sent');
        // Reset the retry delay
        this._retryDelay = START_DELAY;
        // We were successful so check the queue
        this._flushQueue();
    }
    /** Queues a failed request */
    _queueRequest(request) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.log('Queuing request');
            yield this._queue.add(request);
            setTimeout(() => {
                this._flushQueue();
            }, this._retryDelay);
            this._retryDelay *= 3;
            // If the delay is bigger than 2^31 (max signed 32-bit int), setTimeout throws
            // an error and falls back to 1 which can cause a huge number of requests.
            if (this._retryDelay > MAX_DELAY) {
                this._retryDelay = MAX_DELAY;
            }
            return { status: 'unknown' };
        });
    }
    /** Attempts to send the first event in the queue if one is found */
    _flushQueue() {
        void this._queue.pop(this._url).then((found) => {
            if (found) {
                logger.log('Found a request in the queue');
                void this.sendRequest(found);
            }
        });
    }
}
//# sourceMappingURL=electron-offline-net.js.map