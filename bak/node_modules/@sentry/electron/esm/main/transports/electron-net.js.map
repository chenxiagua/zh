{"version":3,"file":"electron-net.js","sourceRoot":"","sources":["../../../src/main/transports/electron-net.ts"],"names":[],"mappings":"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","sourcesContent":["import { getEnvelopeEndpointWithUrlEncodedAuth } from '@sentry/core';\nimport { Transports } from '@sentry/node';\nimport {\n  Event,\n  EventStatus,\n  Response,\n  SentryRequest,\n  SentryRequestType,\n  SessionAggregates,\n  SessionContext,\n  TransportOptions,\n} from '@sentry/types';\nimport { eventStatusFromHttpCode, logger, makePromiseBuffer, PromiseBuffer } from '@sentry/utils';\nimport { net } from 'electron';\nimport { Readable, Writable } from 'stream';\nimport * as url from 'url';\nimport { createGzip } from 'zlib';\n\nimport { getSdkInfo } from '../context';\nimport { whenAppReady } from '../electron-normalize';\n\n// Estimated maximum size for reasonable standalone event\nconst GZIP_THRESHOLD = 1024 * 32;\n\n/** Wraps HTTP errors and includes the status */\nexport class HTTPError extends Error {\n  public constructor(public readonly status: EventStatus, message: string) {\n    super(message);\n  }\n}\n\n/**\n * SentryElectronRequest\n */\nexport interface SentryElectronRequest extends Omit<SentryRequest, 'body'> {\n  body: string | Buffer;\n  date?: Date;\n}\n\n/**\n * Gets a stream from a Buffer or string\n * We don't have Readable.from in earlier versions of node\n */\nfunction streamFromBody(body: Buffer | string): Readable {\n  return new Readable({\n    read() {\n      this.push(body);\n      this.push(null);\n    },\n  });\n}\n\n/** Using net module of Electron */\nexport class ElectronNetTransport extends Transports.BaseTransport {\n  /** A simple buffer holding all requests. */\n  protected readonly _buffer: PromiseBuffer<Response> = makePromiseBuffer(30);\n\n  /** Create a new instance */\n  public constructor(public options: TransportOptions) {\n    super(options);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async sendEvent(event: Event): Promise<Response> {\n    const envelopeHeaders = JSON.stringify({\n      event_id: event.event_id,\n      sent_at: new Date().toISOString(),\n    });\n    const type = event.type || 'event';\n    const itemHeaders = JSON.stringify({ type });\n\n    if (this._isRateLimited(type)) {\n      throw new HTTPError(\n        'rate_limit',\n        `Transport locked till ${JSON.stringify(this._rateLimits, null, 2)} due to too many requests.`,\n      );\n    }\n\n    // Delete this metadata as this should not be sent to Sentry.\n    delete event.sdkProcessingMetadata;\n\n    const eventPayload = JSON.stringify(event);\n    const body = Buffer.from(`${envelopeHeaders}\\n${itemHeaders}\\n${eventPayload}\\n`);\n\n    return this.sendRequest({\n      url: getEnvelopeEndpointWithUrlEncodedAuth(this._api.dsn),\n      body,\n      type,\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendSession(session: SessionContext | SessionAggregates): Promise<Response> {\n    const { name, version } = getSdkInfo();\n\n    const envelopeHeaders = JSON.stringify({\n      sent_at: new Date().toISOString(),\n      sdk: { name, version },\n    });\n\n    // I know this is hacky but we don't want to add `session` to request type since it's never rate limited\n    const type = 'aggregates' in session ? ('sessions' as SentryRequestType) : 'session';\n    const itemHeaders = JSON.stringify({ type });\n    const sessionPayload = JSON.stringify(session);\n    const body = Buffer.from(`${envelopeHeaders}\\n${itemHeaders}\\n${sessionPayload}\\n`);\n\n    return this.sendRequest({\n      url: getEnvelopeEndpointWithUrlEncodedAuth(this._api.dsn),\n      body,\n      type,\n    });\n  }\n\n  /**\n   * Checks if a category is rate-limited\n   */\n  public isRateLimited(category: SentryRequestType): boolean {\n    return this._isRateLimited(category);\n  }\n\n  /**\n   * Dispatches a Request to Sentry. Only handles SentryRequest\n   */\n  public async sendRequest(request: SentryElectronRequest): Promise<Response> {\n    logger.log(`Sending '${request.type}' request`);\n\n    if (this._isRateLimited(request.type)) {\n      throw new HTTPError(\n        'rate_limit',\n        `Transport for ${request.type} requests locked till ${this._disabledUntil(\n          request.type,\n        )} due to too many requests.`,\n      );\n    }\n\n    const options = this._getRequestOptions(new url.URL(request.url));\n    options.headers = {\n      ...options.headers,\n      'Content-Type': 'application/x-sentry-envelope',\n    };\n\n    let bodyStream = streamFromBody(request.body);\n\n    if (request.body.length > GZIP_THRESHOLD) {\n      options.headers['Content-Encoding'] = 'gzip';\n      bodyStream = bodyStream.pipe(createGzip());\n    }\n\n    await whenAppReady;\n\n    return this._buffer.add(\n      () =>\n        new Promise<Response>((resolve, reject) => {\n          const req = net.request(options as Electron.ClientRequestConstructorOptions);\n          req.on('error', reject);\n          req.on('response', (res: Electron.IncomingMessage) => {\n            res.on('error', reject);\n\n            const status = eventStatusFromHttpCode(res.statusCode);\n            if (status === 'success') {\n              resolve({ status });\n            } else {\n              if (status === 'rate_limit') {\n                let retryAfterHeader = res.headers ? res.headers['retry-after'] : '';\n                retryAfterHeader = (Array.isArray(retryAfterHeader) ? retryAfterHeader[0] : retryAfterHeader) as string;\n\n                let rlHeader = res.headers ? res.headers['x-sentry-rate-limits'] : '';\n                rlHeader = (Array.isArray(rlHeader) ? rlHeader[0] : rlHeader) as string;\n\n                if (this._handleRateLimit({ 'x-sentry-rate-limits': rlHeader, 'retry-after': retryAfterHeader })) {\n                  logger.warn(`Too many requests, backing off until: ${this._disabledUntil(request.type)}`);\n                }\n              }\n\n              if (res.headers && res.headers['x-sentry-error']) {\n                let reason: string | string[] = res.headers['x-sentry-error'];\n                if (Array.isArray(reason)) {\n                  reason = reason.join(', ');\n                }\n\n                reject(new HTTPError(status, `HTTP Error (${res.statusCode}): ${reason}`));\n              } else {\n                reject(new HTTPError(status, `HTTP Error (${res.statusCode})`));\n              }\n            }\n            // force the socket to drain\n            res.on('data', () => {\n              // Drain\n            });\n            res.on('end', () => {\n              // Drain\n            });\n          });\n\n          // The docs say that ClientRequest is Writable but the types don't match exactly\n          bodyStream.pipe(req as unknown as Writable);\n        }),\n    );\n  }\n}\n"]}