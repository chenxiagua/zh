import { logger } from '@sentry/utils';
import { existsSync, readFileSync, statSync, unlinkSync, writeFileSync } from 'fs';
import { dirname, join } from 'path';
import { mkdirpSync } from './fs';
const dateFormat = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.*\d{0,10}Z$/;
/** JSON revive function to enable de-serialization of Date objects */
function dateReviver(_, value) {
    if (typeof value === 'string' && dateFormat.test(value)) {
        return new Date(value);
    }
    return value;
}
/**
 * Note, this class is only compatible with Node.
 * Lazily serializes data to a JSON file to persist. When created, it loads data
 * from that file if it already exists.
 */
export class Store {
    /**
     * Creates a new store.
     *
     * @param path A unique filename to store this data.
     * @param id A unique filename to store this data.
     * @param initial An initial value to initialize data with.
     */
    constructor(path, id, initial) {
        this._path = join(path, `${id}.json`);
        this._initial = initial;
        this._flushing = false;
    }
    /**
     * Updates data by replacing it with the given value.
     * @param next New data to replace the previous one.
     * @param forceFlush Forces the write to be flushed to disk immediately
     */
    set(next, forceFlush = false) {
        this._data = next;
        if (!this._flushing) {
            this._flushing = true;
            if (forceFlush) {
                this._flush();
            }
            else {
                setImmediate(() => {
                    this._flush();
                });
            }
        }
    }
    /**
     * Updates data by passing it through the given function.
     * @param fn A function receiving the current data and returning new one.
     */
    update(fn) {
        this.set(fn(this.get()));
    }
    /**
     * Returns the current data.
     *
     * When invoked for the first time, it will try to load previously stored data
     * from disk. If the file does not exist, the initial value provided to the
     * constructor is used.
     */
    get() {
        if (this._data === undefined) {
            try {
                this._data = existsSync(this._path)
                    ? JSON.parse(readFileSync(this._path, 'utf8'), dateReviver)
                    : this._initial;
            }
            catch (e) {
                this._data = this._initial;
            }
        }
        return this._data;
    }
    /** Returns store to its initial state */
    clear() {
        this.set(this._initial);
    }
    /** Gets the Date that the file was last modified */
    getModifiedDate() {
        var _a;
        try {
            return (_a = statSync(this._path)) === null || _a === void 0 ? void 0 : _a.mtime;
        }
        catch (_) {
            return undefined;
        }
    }
    /** Serializes the current data into the JSON file. */
    _flush() {
        try {
            if (this._data === undefined) {
                unlinkSync(this._path);
            }
            else {
                mkdirpSync(dirname(this._path));
                writeFileSync(this._path, JSON.stringify(this._data));
            }
        }
        catch (e) {
            logger.warn('Failed to flush store', e);
            // This usually fails due to anti virus scanners, issues in the file
            // system, or problems with network drives. We cannot fix or handle this
            // issue and must resume gracefully. Thus, we have to ignore this error.
        }
        finally {
            this._flushing = false;
        }
    }
}
//# sourceMappingURL=store.js.map