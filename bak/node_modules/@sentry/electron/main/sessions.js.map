{"version":3,"file":"sessions.js","sourceRoot":"","sources":["../src/main/sessions.ts"],"names":[],"mappings":"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","sourcesContent":["import { getCurrentHub } from '@sentry/core';\nimport { flush, NodeClient } from '@sentry/node';\nimport { SessionContext, SessionStatus } from '@sentry/types';\nimport { logger } from '@sentry/utils';\n\nimport { sentryCachePath } from './fs';\nimport { Store } from './store';\nimport { ElectronNetTransport } from './transports/electron-net';\n\nconst PERSIST_INTERVAL_MS = 60_000;\n\n/** Stores the app session in case of termination due to main process crash or app killed */\nconst sessionStore = new Store<SessionContext | undefined>(sentryCachePath, 'session', undefined);\n\n/** Previous session that did not exit cleanly */\nlet previousSession = sessionStore.get();\nconst previousSessionModified = sessionStore.getModifiedDate();\n\nlet persistTimer: NodeJS.Timer | undefined;\n\n/** Starts a session */\nexport function startSession(): void {\n  const hub = getCurrentHub();\n  sessionStore.set(hub.startSession());\n\n  // Every PERSIST_INTERVAL, write the session to disk\n  persistTimer = setInterval(() => {\n    const currentSession = hub.getScope()?.getSession();\n    // Only bother saving if it hasn't already ended\n    if (currentSession && currentSession.status === 'ok') {\n      sessionStore.set(currentSession);\n    }\n  }, PERSIST_INTERVAL_MS);\n}\n\n/** Cleanly ends a session */\nexport async function endSession(): Promise<void> {\n  // Once the session had ended there is no point persisting it\n  if (persistTimer) {\n    clearInterval(persistTimer);\n  }\n\n  const hub = getCurrentHub();\n  const session = hub.getScope()?.getSession();\n\n  if (session) {\n    if (session.status === 'ok') {\n      logger.log('Ending session');\n      hub.endSession();\n    } else {\n      logger.log('Session was already ended');\n    }\n  } else {\n    logger.log('No session');\n  }\n\n  sessionStore.set(undefined, true);\n\n  await flush();\n}\n\n/** Determines if a Date is likely to have occurred in the previous uncompleted session */\nexport function unreportedDuringLastSession(crashDate: Date | undefined): boolean {\n  if (!crashDate) {\n    return false;\n  }\n\n  // There is no previous session\n  if (!previousSessionModified) {\n    return false;\n  }\n\n  const previousSessionModifiedTime = previousSessionModified.getTime();\n  const crashTime = crashDate.getTime();\n\n  // Session could have run until modified time + persist interval\n  const prevSessionEnd = previousSessionModifiedTime + PERSIST_INTERVAL_MS;\n\n  // Event cannot have occurred before last persist time, We add a 2 second overlap to be sure\n  const lastPersist = previousSessionModifiedTime - 2_000;\n\n  // If the crash occurred between the last persist and estimated end of session\n  return crashTime > lastPersist && crashTime < prevSessionEnd;\n}\n\n/** Checks if the previous session needs sending as crashed or abnormal  */\nexport async function checkPreviousSession(crashed: boolean): Promise<void> {\n  if (previousSession) {\n    // Ignore if the previous session is already ended\n    if (previousSession.status !== 'ok') {\n      previousSession = undefined;\n      return;\n    }\n\n    const status: SessionStatus = crashed ? 'crashed' : 'abnormal';\n\n    logger.log(`Found previous ${status} session`);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    const transport = (getCurrentHub().getClient<NodeClient>() as any)\n      ._getBackend()\n      .getTransport() as ElectronNetTransport;\n\n    await transport.sendSession({ ...previousSession, status, errors: (previousSession.errors || 0) + 1 });\n\n    previousSession = undefined;\n  }\n}\n\n/** Sets the current session as crashed */\nexport function sessionCrashed(): void {\n  // stop persisting session\n  if (persistTimer) {\n    clearInterval(persistTimer);\n  }\n\n  logger.log('Session Crashed');\n  const hub = getCurrentHub();\n  const session = hub.getScope()?.getSession();\n\n  if (!session) {\n    logger.log('No session to update');\n    return;\n  }\n\n  if (session.status === 'ok') {\n    logger.log('Setting session as crashed');\n    session.update({ status: 'crashed', errors: (session.errors += 1) });\n  } else {\n    logger.log('Session already ended');\n  }\n\n  hub.captureSession();\n}\n"]}