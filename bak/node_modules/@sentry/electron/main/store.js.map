{"version":3,"file":"store.js","sourceRoot":"","sources":["../src/main/store.ts"],"names":[],"mappings":"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","sourcesContent":["import { logger } from '@sentry/utils';\nimport { existsSync, readFileSync, statSync, unlinkSync, writeFileSync } from 'fs';\nimport { dirname, join } from 'path';\n\nimport { mkdirpSync } from './fs';\n\nconst dateFormat = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.*\\d{0,10}Z$/;\n\n/** JSON revive function to enable de-serialization of Date objects */\nfunction dateReviver(_: string, value: any): any {\n  if (typeof value === 'string' && dateFormat.test(value)) {\n    return new Date(value);\n  }\n\n  return value;\n}\n\n/**\n * Note, this class is only compatible with Node.\n * Lazily serializes data to a JSON file to persist. When created, it loads data\n * from that file if it already exists.\n */\nexport class Store<T> {\n  /** Internal path for JSON file. */\n  private readonly _path: string;\n  /** Value used to initialize data for the first time. */\n  private readonly _initial: T;\n  /** Current state of the data. */\n  private _data?: T;\n  /** State whether a flush to disk has been requested in this cycle. */\n  private _flushing: boolean;\n\n  /**\n   * Creates a new store.\n   *\n   * @param path A unique filename to store this data.\n   * @param id A unique filename to store this data.\n   * @param initial An initial value to initialize data with.\n   */\n  public constructor(path: string, id: string, initial: T) {\n    this._path = join(path, `${id}.json`);\n    this._initial = initial;\n    this._flushing = false;\n  }\n\n  /**\n   * Updates data by replacing it with the given value.\n   * @param next New data to replace the previous one.\n   * @param forceFlush Forces the write to be flushed to disk immediately\n   */\n  public set(next: T, forceFlush: boolean = false): void {\n    this._data = next;\n\n    if (!this._flushing) {\n      this._flushing = true;\n      if (forceFlush) {\n        this._flush();\n      } else {\n        setImmediate(() => {\n          this._flush();\n        });\n      }\n    }\n  }\n\n  /**\n   * Updates data by passing it through the given function.\n   * @param fn A function receiving the current data and returning new one.\n   */\n  public update(fn: (current: T) => T): void {\n    this.set(fn(this.get()));\n  }\n\n  /**\n   * Returns the current data.\n   *\n   * When invoked for the first time, it will try to load previously stored data\n   * from disk. If the file does not exist, the initial value provided to the\n   * constructor is used.\n   */\n  public get(): T {\n    if (this._data === undefined) {\n      try {\n        this._data = existsSync(this._path)\n          ? (JSON.parse(readFileSync(this._path, 'utf8'), dateReviver) as T)\n          : this._initial;\n      } catch (e) {\n        this._data = this._initial;\n      }\n    }\n\n    return this._data;\n  }\n\n  /** Returns store to its initial state */\n  public clear(): void {\n    this.set(this._initial);\n  }\n\n  /** Gets the Date that the file was last modified */\n  public getModifiedDate(): Date | undefined {\n    try {\n      return statSync(this._path)?.mtime;\n    } catch (_) {\n      return undefined;\n    }\n  }\n\n  /** Serializes the current data into the JSON file. */\n  private _flush(): void {\n    try {\n      if (this._data === undefined) {\n        unlinkSync(this._path);\n      } else {\n        mkdirpSync(dirname(this._path));\n        writeFileSync(this._path, JSON.stringify(this._data));\n      }\n    } catch (e) {\n      logger.warn('Failed to flush store', e);\n      // This usually fails due to anti virus scanners, issues in the file\n      // system, or problems with network drives. We cannot fix or handle this\n      // issue and must resume gracefully. Thus, we have to ignore this error.\n    } finally {\n      this._flushing = false;\n    }\n  }\n}\n"]}