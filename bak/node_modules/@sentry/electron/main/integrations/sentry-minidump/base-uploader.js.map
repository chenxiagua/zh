{"version":3,"file":"base-uploader.js","sourceRoot":"","sources":["../../../src/main/integrations/sentry-minidump/base-uploader.ts"],"names":[],"mappings":"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","sourcesContent":["import { getEnvelopeEndpointWithUrlEncodedAuth } from '@sentry/core';\nimport { NodeOptions } from '@sentry/node';\nimport { DsnComponents, Event, Transport } from '@sentry/types';\nimport { isThenable, logger, makeDsn, SentryError, timestampWithMs } from '@sentry/utils';\nimport { basename } from 'path';\n\nimport { readFileAsync, statAsync, unlinkAsync } from '../../fs';\nimport { ElectronNetTransport, SentryElectronRequest } from '../../transports/electron-net';\n\n/** Maximum number of days to keep a minidump before deleting it. */\nconst MAX_AGE = 30;\n\n/**\n * Payload for a minidump request comprising a persistent file system path and\n * event metadata.\n */\nexport interface MinidumpRequest {\n  /** Path to the minidump file. */\n  path: string;\n  /** Associated event data. */\n  event: Event | null;\n}\n\n/**\n * A service that discovers Minidump crash reports and uploads them to Sentry.\n */\nexport abstract class BaseUploader {\n  /** List of minidumps that have been found already. */\n  private readonly _knownPaths: string[];\n\n  /** API object */\n  private readonly _dsn: DsnComponents;\n\n  /**\n   * Creates a new uploader instance.\n   */\n  public constructor(private readonly _options: NodeOptions, private readonly _transport: Transport) {\n    this._knownPaths = [];\n\n    if (!_options.dsn) {\n      throw new SentryError('Attempted to enable Electron native crash reporter but no DSN was supplied');\n    }\n\n    this._dsn = makeDsn(_options.dsn);\n  }\n\n  /**\n   * Uploads a minidump file to Sentry.\n   *\n   * @param path Absolute path to the minidump file.\n   * @param event Event data to attach to the minidump.\n   * @returns A promise that resolves when the upload is complete.\n   */\n  public async uploadMinidump(request: MinidumpRequest): Promise<void> {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (typeof (this._transport as any).sendRequest !== 'function') {\n      logger.warn(\"Your transport doesn't implement sendRequest\");\n      logger.warn('Skipping sending minidump');\n      return;\n    }\n\n    // The beforeSend callback can set the event as null\n    if (this._options.beforeSend && request.event) {\n      const maybePromiseResult = this._options.beforeSend(request.event);\n\n      const result = await (isThenable(maybePromiseResult)\n        ? (maybePromiseResult as PromiseLike<Event | null>).then((e) => e)\n        : Promise.resolve(maybePromiseResult));\n\n      if (result === null) {\n        logger.warn('`beforeSend` returned `null`, will not send minidump.');\n        request.event = null;\n      }\n    }\n\n    const transport = this._transport as ElectronNetTransport;\n    try {\n      if (request.event && !transport.isRateLimited('event')) {\n        logger.log('Sending minidump', request.path);\n        const requestForTransport = await this._toMinidumpRequest(transport, request.event, request.path);\n        await transport.sendRequest(requestForTransport);\n      }\n\n      // We either succeeded, something went wrong or the send was aborted. Either way, we can remove the minidump file.\n      try {\n        await unlinkAsync(request.path);\n        logger.log('Deleted minidump', request.path);\n      } catch (e) {\n        logger.warn('Could not delete', request.path, e);\n      }\n\n      // Forget this minidump in all caches\n      this._knownPaths.splice(this._knownPaths.indexOf(request.path), 1);\n    } catch (err) {\n      // TODO: Test this\n      logger.warn('Failed to upload minidump', err);\n    }\n  }\n\n  /**\n   * Searches for new, unknown minidump files in the crash directory.\n   * @returns A promise that resolves to absolute paths of those dumps.\n   */\n  public async getNewMinidumps(): Promise<string[]> {\n    const minidumps = await this._getMinidumpPaths();\n    logger.log(`Found ${minidumps.length} minidumps`);\n\n    const oldestMs = new Date().getTime() - MAX_AGE * 24 * 3_600 * 1_000;\n    return this._filterAsync(minidumps, async (path) => {\n      // Skip files that we have seen before\n      if (this._knownPaths.indexOf(path) >= 0) {\n        return false;\n      }\n\n      // Lock this minidump until we have uploaded it or an error occurs and we\n      // remove it from the file system.\n      this._knownPaths.push(path);\n\n      // We do not want to upload minidumps that have been generated before a\n      // certain threshold. Those old files can be deleted immediately.\n      const stats = await statAsync(path);\n      if (stats.birthtimeMs < oldestMs) {\n        try {\n          await unlinkAsync(path);\n        } catch (e) {\n          logger.warn('Could not delete', path);\n        }\n        this._knownPaths.splice(this._knownPaths.indexOf(path), 1);\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  /**\n   * Helper to filter an array with asynchronous callbacks.\n   *\n   * @param array An array containing items to filter.\n   * @param predicate An async predicate evaluated on every item.\n   * @param thisArg Optional value passed as \"this\" into the callback.\n   * @returns An array containing only values where the callback returned true.\n   */\n  private async _filterAsync<T>(\n    array: T[],\n    predicate: (item: T) => Promise<boolean> | boolean,\n    thisArg?: any,\n  ): Promise<T[]> {\n    const verdicts = await Promise.all(array.map(predicate, thisArg));\n    return array.filter((_, index) => verdicts[index]);\n  }\n\n  /**\n   * Create minidump request to dispatch to the transport\n   */\n  private async _toMinidumpRequest(\n    transport: ElectronNetTransport,\n    event: Event,\n    minidumpPath: string,\n  ): Promise<SentryElectronRequest> {\n    const envelopeHeaders = JSON.stringify({\n      event_id: event.event_id,\n      // Internal helper that uses `perf_hooks` to get clock reading\n      sent_at: new Date(timestampWithMs() * 1_000).toISOString(),\n    });\n\n    // If attachments are rate-limited we add this hint so users know\n    if (transport.isRateLimited('attachment')) {\n      event.message = 'Ratelimited - Minidump Event';\n    }\n\n    const itemHeaders = JSON.stringify({\n      content_type: 'application/json',\n      type: 'event',\n    });\n\n    const eventPayload = JSON.stringify(event);\n    let bodyBuffer = Buffer.from(`${envelopeHeaders}\\n${itemHeaders}\\n${eventPayload}\\n`);\n\n    // Only add attachment if they are not rate limited\n    if (!transport.isRateLimited('attachment')) {\n      let minidumpContent = (await readFileAsync(minidumpPath)) as Buffer;\n\n      // Breakpad has custom parsing\n      minidumpContent = (await this._preProcessFile?.(minidumpContent)) || minidumpContent;\n\n      const minidumpHeader = JSON.stringify({\n        attachment_type: 'event.minidump',\n        length: minidumpContent.length,\n        type: 'attachment',\n        filename: basename(minidumpPath),\n      });\n\n      bodyBuffer = Buffer.concat([bodyBuffer, Buffer.from(`${minidumpHeader}\\n`), minidumpContent, Buffer.from('\\n')]);\n    } else {\n      logger.warn('Will not add minidump to request since they are rate limited.');\n    }\n\n    return {\n      url: getEnvelopeEndpointWithUrlEncodedAuth(this._dsn),\n      body: bodyBuffer,\n      type: 'event',\n    };\n  }\n\n  protected abstract _getMinidumpPaths(): Promise<string[]>;\n\n  protected abstract _preProcessFile(file: Buffer): Buffer | undefined;\n}\n"]}