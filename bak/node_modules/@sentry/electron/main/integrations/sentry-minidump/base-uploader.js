Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseUploader = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@sentry/core");
const utils_1 = require("@sentry/utils");
const path_1 = require("path");
const fs_1 = require("../../fs");
/** Maximum number of days to keep a minidump before deleting it. */
const MAX_AGE = 30;
/**
 * A service that discovers Minidump crash reports and uploads them to Sentry.
 */
class BaseUploader {
    /**
     * Creates a new uploader instance.
     */
    constructor(_options, _transport) {
        this._options = _options;
        this._transport = _transport;
        this._knownPaths = [];
        if (!_options.dsn) {
            throw new utils_1.SentryError('Attempted to enable Electron native crash reporter but no DSN was supplied');
        }
        this._dsn = (0, utils_1.makeDsn)(_options.dsn);
    }
    /**
     * Uploads a minidump file to Sentry.
     *
     * @param path Absolute path to the minidump file.
     * @param event Event data to attach to the minidump.
     * @returns A promise that resolves when the upload is complete.
     */
    uploadMinidump(request) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            if (typeof this._transport.sendRequest !== 'function') {
                utils_1.logger.warn("Your transport doesn't implement sendRequest");
                utils_1.logger.warn('Skipping sending minidump');
                return;
            }
            // The beforeSend callback can set the event as null
            if (this._options.beforeSend && request.event) {
                const maybePromiseResult = this._options.beforeSend(request.event);
                const result = yield ((0, utils_1.isThenable)(maybePromiseResult)
                    ? maybePromiseResult.then((e) => e)
                    : Promise.resolve(maybePromiseResult));
                if (result === null) {
                    utils_1.logger.warn('`beforeSend` returned `null`, will not send minidump.');
                    request.event = null;
                }
            }
            const transport = this._transport;
            try {
                if (request.event && !transport.isRateLimited('event')) {
                    utils_1.logger.log('Sending minidump', request.path);
                    const requestForTransport = yield this._toMinidumpRequest(transport, request.event, request.path);
                    yield transport.sendRequest(requestForTransport);
                }
                // We either succeeded, something went wrong or the send was aborted. Either way, we can remove the minidump file.
                try {
                    yield (0, fs_1.unlinkAsync)(request.path);
                    utils_1.logger.log('Deleted minidump', request.path);
                }
                catch (e) {
                    utils_1.logger.warn('Could not delete', request.path, e);
                }
                // Forget this minidump in all caches
                this._knownPaths.splice(this._knownPaths.indexOf(request.path), 1);
            }
            catch (err) {
                // TODO: Test this
                utils_1.logger.warn('Failed to upload minidump', err);
            }
        });
    }
    /**
     * Searches for new, unknown minidump files in the crash directory.
     * @returns A promise that resolves to absolute paths of those dumps.
     */
    getNewMinidumps() {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const minidumps = yield this._getMinidumpPaths();
            utils_1.logger.log(`Found ${minidumps.length} minidumps`);
            const oldestMs = new Date().getTime() - MAX_AGE * 24 * 3600 * 1000;
            return this._filterAsync(minidumps, (path) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                // Skip files that we have seen before
                if (this._knownPaths.indexOf(path) >= 0) {
                    return false;
                }
                // Lock this minidump until we have uploaded it or an error occurs and we
                // remove it from the file system.
                this._knownPaths.push(path);
                // We do not want to upload minidumps that have been generated before a
                // certain threshold. Those old files can be deleted immediately.
                const stats = yield (0, fs_1.statAsync)(path);
                if (stats.birthtimeMs < oldestMs) {
                    try {
                        yield (0, fs_1.unlinkAsync)(path);
                    }
                    catch (e) {
                        utils_1.logger.warn('Could not delete', path);
                    }
                    this._knownPaths.splice(this._knownPaths.indexOf(path), 1);
                    return false;
                }
                return true;
            }));
        });
    }
    /**
     * Helper to filter an array with asynchronous callbacks.
     *
     * @param array An array containing items to filter.
     * @param predicate An async predicate evaluated on every item.
     * @param thisArg Optional value passed as "this" into the callback.
     * @returns An array containing only values where the callback returned true.
     */
    _filterAsync(array, predicate, thisArg) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const verdicts = yield Promise.all(array.map(predicate, thisArg));
            return array.filter((_, index) => verdicts[index]);
        });
    }
    /**
     * Create minidump request to dispatch to the transport
     */
    _toMinidumpRequest(transport, event, minidumpPath) {
        var _a;
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const envelopeHeaders = JSON.stringify({
                event_id: event.event_id,
                // Internal helper that uses `perf_hooks` to get clock reading
                sent_at: new Date((0, utils_1.timestampWithMs)() * 1000).toISOString(),
            });
            // If attachments are rate-limited we add this hint so users know
            if (transport.isRateLimited('attachment')) {
                event.message = 'Ratelimited - Minidump Event';
            }
            const itemHeaders = JSON.stringify({
                content_type: 'application/json',
                type: 'event',
            });
            const eventPayload = JSON.stringify(event);
            let bodyBuffer = Buffer.from(`${envelopeHeaders}\n${itemHeaders}\n${eventPayload}\n`);
            // Only add attachment if they are not rate limited
            if (!transport.isRateLimited('attachment')) {
                let minidumpContent = (yield (0, fs_1.readFileAsync)(minidumpPath));
                // Breakpad has custom parsing
                minidumpContent = (yield ((_a = this._preProcessFile) === null || _a === void 0 ? void 0 : _a.call(this, minidumpContent))) || minidumpContent;
                const minidumpHeader = JSON.stringify({
                    attachment_type: 'event.minidump',
                    length: minidumpContent.length,
                    type: 'attachment',
                    filename: (0, path_1.basename)(minidumpPath),
                });
                bodyBuffer = Buffer.concat([bodyBuffer, Buffer.from(`${minidumpHeader}\n`), minidumpContent, Buffer.from('\n')]);
            }
            else {
                utils_1.logger.warn('Will not add minidump to request since they are rate limited.');
            }
            return {
                url: (0, core_1.getEnvelopeEndpointWithUrlEncodedAuth)(this._dsn),
                body: bodyBuffer,
                type: 'event',
            };
        });
    }
}
exports.BaseUploader = BaseUploader;
//# sourceMappingURL=base-uploader.js.map