{"version":3,"file":"electron-offline-net.js","sourceRoot":"","sources":["../../src/main/transports/electron-offline-net.ts"],"names":[],"mappings":"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","sourcesContent":["import { getEnvelopeEndpointWithUrlEncodedAuth } from '@sentry/core';\nimport { Response, TransportOptions } from '@sentry/types';\nimport { logger } from '@sentry/utils';\nimport { net } from 'electron';\nimport { join } from 'path';\n\nimport { sentryCachePath } from '../fs';\nimport { ElectronNetTransport, HTTPError, SentryElectronRequest } from './electron-net';\nimport { PersistedRequestQueue } from './queue';\n\nconst START_DELAY = 5_000;\nconst MAX_DELAY = 2_000_000_000;\n\n/** Returns true is there's a chance we're online */\nfunction maybeOnline(): boolean {\n  return !('online' in net) || net.online === true;\n}\n\n/** Using net module of Electron */\nexport class ElectronOfflineNetTransport extends ElectronNetTransport {\n  private _queue: PersistedRequestQueue = new PersistedRequestQueue(join(sentryCachePath, 'queue'));\n  private _url: string = getEnvelopeEndpointWithUrlEncodedAuth(this._api.dsn);\n  private _retryDelay: number = START_DELAY;\n\n  /** Create a new instance  */\n  public constructor(public options: TransportOptions) {\n    super(options);\n\n    this._flushQueue();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async sendRequest(request: SentryElectronRequest): Promise<Response> {\n    if (maybeOnline()) {\n      try {\n        const response = await super.sendRequest(request);\n        this._requestSuccess();\n        return response;\n      } catch (error) {\n        if (error instanceof HTTPError && error.status !== 'rate_limit') {\n          // We don't queue HTTP errors that are not rate limited\n          logger.warn('Dropping request:', error);\n          return { status: 'failed' };\n        } else {\n          logger.log('Error sending:', error);\n        }\n      }\n    } else {\n      logger.log(`Currently Offline. Not sending '${request.type}' request. `);\n    }\n\n    return await this._queueRequest(request);\n  }\n\n  /** Records successful submission */\n  private _requestSuccess(): void {\n    logger.log('Successfully sent');\n    // Reset the retry delay\n    this._retryDelay = START_DELAY;\n    // We were successful so check the queue\n    this._flushQueue();\n  }\n\n  /** Queues a failed request */\n  private async _queueRequest(request: SentryElectronRequest): Promise<Response> {\n    logger.log('Queuing request');\n    await this._queue.add(request);\n\n    setTimeout(() => {\n      this._flushQueue();\n    }, this._retryDelay);\n\n    this._retryDelay *= 3;\n\n    // If the delay is bigger than 2^31 (max signed 32-bit int), setTimeout throws\n    // an error and falls back to 1 which can cause a huge number of requests.\n    if (this._retryDelay > MAX_DELAY) {\n      this._retryDelay = MAX_DELAY;\n    }\n\n    return { status: 'unknown' };\n  }\n\n  /** Attempts to send the first event in the queue if one is found */\n  private _flushQueue(): void {\n    void this._queue.pop(this._url).then((found) => {\n      if (found) {\n        logger.log('Found a request in the queue');\n        void this.sendRequest(found);\n      }\n    });\n  }\n}\n"]}