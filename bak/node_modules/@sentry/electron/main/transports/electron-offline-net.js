Object.defineProperty(exports, "__esModule", { value: true });
exports.ElectronOfflineNetTransport = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@sentry/core");
const utils_1 = require("@sentry/utils");
const electron_1 = require("electron");
const path_1 = require("path");
const fs_1 = require("../fs");
const electron_net_1 = require("./electron-net");
const queue_1 = require("./queue");
const START_DELAY = 5000;
const MAX_DELAY = 2000000000;
/** Returns true is there's a chance we're online */
function maybeOnline() {
    return !('online' in electron_1.net) || electron_1.net.online === true;
}
/** Using net module of Electron */
class ElectronOfflineNetTransport extends electron_net_1.ElectronNetTransport {
    /** Create a new instance  */
    constructor(options) {
        super(options);
        this.options = options;
        this._queue = new queue_1.PersistedRequestQueue((0, path_1.join)(fs_1.sentryCachePath, 'queue'));
        this._url = (0, core_1.getEnvelopeEndpointWithUrlEncodedAuth)(this._api.dsn);
        this._retryDelay = START_DELAY;
        this._flushQueue();
    }
    /**
     * @inheritDoc
     */
    sendRequest(request) {
        const _super = Object.create(null, {
            sendRequest: { get: () => super.sendRequest }
        });
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            if (maybeOnline()) {
                try {
                    const response = yield _super.sendRequest.call(this, request);
                    this._requestSuccess();
                    return response;
                }
                catch (error) {
                    if (error instanceof electron_net_1.HTTPError && error.status !== 'rate_limit') {
                        // We don't queue HTTP errors that are not rate limited
                        utils_1.logger.warn('Dropping request:', error);
                        return { status: 'failed' };
                    }
                    else {
                        utils_1.logger.log('Error sending:', error);
                    }
                }
            }
            else {
                utils_1.logger.log(`Currently Offline. Not sending '${request.type}' request. `);
            }
            return yield this._queueRequest(request);
        });
    }
    /** Records successful submission */
    _requestSuccess() {
        utils_1.logger.log('Successfully sent');
        // Reset the retry delay
        this._retryDelay = START_DELAY;
        // We were successful so check the queue
        this._flushQueue();
    }
    /** Queues a failed request */
    _queueRequest(request) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            utils_1.logger.log('Queuing request');
            yield this._queue.add(request);
            setTimeout(() => {
                this._flushQueue();
            }, this._retryDelay);
            this._retryDelay *= 3;
            // If the delay is bigger than 2^31 (max signed 32-bit int), setTimeout throws
            // an error and falls back to 1 which can cause a huge number of requests.
            if (this._retryDelay > MAX_DELAY) {
                this._retryDelay = MAX_DELAY;
            }
            return { status: 'unknown' };
        });
    }
    /** Attempts to send the first event in the queue if one is found */
    _flushQueue() {
        void this._queue.pop(this._url).then((found) => {
            if (found) {
                utils_1.logger.log('Found a request in the queue');
                void this.sendRequest(found);
            }
        });
    }
}
exports.ElectronOfflineNetTransport = ElectronOfflineNetTransport;
//# sourceMappingURL=electron-offline-net.js.map