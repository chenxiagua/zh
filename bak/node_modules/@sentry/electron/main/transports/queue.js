Object.defineProperty(exports, "__esModule", { value: true });
exports.PersistedRequestQueue = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("@sentry/utils");
const path_1 = require("path");
const fs_1 = require("../fs");
const store_1 = require("../store");
const MILLISECONDS_PER_DAY = 86400000;
/** A request queue that is persisted to disk to survive app restarts */
class PersistedRequestQueue {
    constructor(_queuePath, _maxAgeDays = 30, _maxCount = 30) {
        this._queuePath = _queuePath;
        this._maxAgeDays = _maxAgeDays;
        this._maxCount = _maxCount;
        this._queue = new store_1.Store(this._queuePath, 'queue', []);
    }
    /** Adds a request to the queue */
    add(request) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const bodyPath = (0, utils_1.uuid4)();
            this._queue.update((queue) => {
                queue.push({
                    bodyPath,
                    type: request.type,
                    date: request.date || new Date(),
                });
                while (queue.length > this._maxCount) {
                    const removed = queue.shift();
                    if (removed) {
                        void this._removeBody(removed.bodyPath);
                    }
                }
                return queue;
            });
            try {
                yield (0, fs_1.writeFileAsync)((0, path_1.join)(this._queuePath, bodyPath), request.body);
            }
            catch (_) {
                //
            }
        });
    }
    /** Pops the oldest event from the queue */
    pop(url) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            let found;
            const cutOff = Date.now() - MILLISECONDS_PER_DAY * this._maxAgeDays;
            this._queue.update((queue) => {
                while ((found = queue.shift())) {
                    if (found.date.getTime() < cutOff) {
                        // we're dropping this event so delete the body
                        void this._removeBody(found.bodyPath);
                        found = undefined;
                    }
                    else {
                        break;
                    }
                }
                return queue;
            });
            if (found) {
                try {
                    const body = yield (0, fs_1.readFileAsync)((0, path_1.join)(this._queuePath, found.bodyPath));
                    void this._removeBody(found.bodyPath);
                    return {
                        body,
                        date: found.date,
                        type: found.type,
                        url,
                    };
                }
                catch (e) {
                    // eslint-disable-next-line no-console
                    utils_1.logger.warn('Filed to read queued request body', e);
                }
            }
            return undefined;
        });
    }
    /** */
    _removeBody(bodyPath) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            try {
                yield (0, fs_1.unlinkAsync)((0, path_1.join)(this._queuePath, bodyPath));
            }
            catch (_) {
                //
            }
        });
    }
}
exports.PersistedRequestQueue = PersistedRequestQueue;
//# sourceMappingURL=queue.js.map